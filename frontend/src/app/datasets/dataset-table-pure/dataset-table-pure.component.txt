import { DatePipe } from '@angular/common';
import {
  Component,
  EventEmitter,
  Input,
  OnInit,
  Output,
  ViewChild,
  OnDestroy
} from '@angular/core';
import { Http } from '@angular/http';
import { Router, ActivatedRoute } from '@angular/router';
import { Store } from '@ngrx/store';
import { Subject } from 'rxjs/Subject';
import { Job, Dataset } from 'shared/sdk/models';
import { UserApi } from 'shared/sdk/services';
import { ConfigService } from 'shared/services/config.service';
import * as dua from 'state-management/actions/dashboard-ui.actions';
import * as dsa from 'state-management/actions/datasets.actions';
import * as selectors from 'state-management/selectors';
import * as ua from 'state-management/actions/user.actions';
import * as ja from 'state-management/actions/jobs.actions';
import { Message, MessageType } from 'state-management/models';
import { Angular5Csv } from 'angular5-csv/Angular5-csv';
import * as utils from 'shared/utils';

import { config } from '../../../config/config';
import { last } from 'rxjs/operator/last';
import { Observable } from 'rxjs/Observable';

import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { MatTableDataSource, MatPaginator, MatSort, MatDialog } from '@angular/material';
import { AfterViewInit } from '@angular/core/src/metadata/lifecycle_hooks';
import { SelectionModel } from '@angular/cdk/collections';

import { DialogComponent } from 'shared/modules/dialog/dialog.component';
import * as rison from 'rison';
import * as filesize from 'filesize';

@Component({
  selector: 'dataset-table-pure',
  templateUrl: './dataset-table-pure.component.html',
  styleUrls: ['./dataset-table-pure.component.scss']
})
export class DatasetTablePureComponent {
  @Input() datasets = [];
  
  /*@ViewChild(MatSort) sort: MatSort;
  @ViewChild(MatPaginator) paginator: MatPaginator;*/

  //selection = new SelectionModel<Element>(true, []);
  datasetCount$;
  dataSource: MatTableDataSource<any> | null;
  displayedColumns = ['select', 'pid'];

  modeButtons = ['Archive', 'View', 'Retrieve'];

  cols = [];
  loading$: any = false;
  limit$: any = 10;

  mode = 'view';

  aremaOptions = 'archiveretrieve';

  retrieveDisplay = false;
  //dest = new Subject<string>();

  subscriptions = [];

  rowStyleMap = {};

  paranms = {};

  filters = {};

  archiveable;
  retrievable;

  getRowValue(row, col) {
    const field = col.field;
    const value = row[field];

    if (field === 'creationTime') {
      const date = new Date(value);
      const datePipe = new DatePipe('en-US');
      const formattedDate = datePipe.transform(date, 'dd/MM/yyyy HH:mm');
      return formattedDate;
    }

    if (field === 'size') {
      return filesize(value || 0);
    }

    if (field === 'datasetlifecycle.archiveStatusMessage') {
      const val = row.datasetlifecycle ? row.datasetlifecycle.archiveStatusMessage : '';
      return config.datasetStatusMessages[val] || val;
    }

    if (field === 'datasetlifecycle.retrieveStatusMessage') {
      const val = row.datasetlifecycle ? row.datasetlifecycle.retrieveStatusMessage : '';
      return config.datasetStatusMessages[val] || val;
    }
    return value;
  }

  ngOnInit() {

    /*this.configSrv.getConfigFile('Dataset').subscribe(conf => {
      if (conf) {
        for (const prop in conf) {
          if (prop in conf && 'table' in conf[prop]) {
            this.cols.push(conf[prop]['table']);
            this.displayedColumns.push(conf[prop]['table']['field']);
          }
        }
      }
    });*/
  }

  onRowSelect(event, row) {
    /*const pid = encodeURIComponent(row.pid);
    this.router.navigateByUrl(
      '/dataset/' + pid
    );*/
  }

  onRowCheck(row) {
    /*this.selection.toggle(row);
    this.store.dispatch({
      type: dsa.SELECTED_UPDATE,
      payload: this.selection.selected
    });
    // this.selectedSet.emit(this.selection.selected);
    */
  }

  calculateRowClasses(row) {
    if (row.datasetlifecycle && this.mode === 'archive'
      && (this.archiveable.indexOf(row.datasetlifecycle.archiveStatusMessage) !== -1) && row.size !== 0) {
      return {
        'row-archiveable': true
      };
    } else if (row.datasetlifecycle && this.mode === 'retrieve'
      && this.retrievable.indexOf(row.datasetlifecycle.archiveStatusMessage) !== -1 && row.size !== 0) {
      return {
        'row-retrievable': true
      };
    } else if (row.size === 0) {
      return {
        'row-empty': true
      };
    } else {
      return {
        'row-generic': true
      };
    }
  }

  /**
   * Handle changing of view mode and disabling selected rows
   * @param event
   * @param mode
   */
  onModeChange(event, mode) {
    /*if (mode) {
      this.mode = mode.toLowerCase();
      this.store.dispatch(new dua.SaveModeAction(this.mode));
    }*/
  }

  isAllSelected() {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSource.data.length;
    return numSelected === numRows;
  }

  /** Selects all rows if they are not all selected; otherwise clear selection. */
  masterToggle() {
    /*this.isAllSelected() ?
      this.selection.clear() :
      this.dataSource.data.forEach(row => this.selection.select(row));
    this.store.dispatch({
      type: dsa.SELECTED_UPDATE,
      payload: this.selection.selected
    });*/
  }

  updateRowView(mode) {
    this.selection.clear();
    this.rowStyleMap = {};
    const activeSets = [];
    if (this.datasets && this.datasets.length > 0 && (this.mode === 'archive' || this.mode === 'retrieve')) {
      for (let d = 0; d < this.datasets.length; d++) {
        const set = this.datasets[d];
        const msg = (set.datasetlifecycle && set.datasetlifecycle.archiveStatusMessage) || '';
        if (this.mode === 'archive'
          && set.datasetlifecycle
          && (this.archiveable.indexOf(set.datasetlifecycle.archiveStatusMessage) !== -1) && set.size > 0) {
          activeSets.push(set);
        } else if (this.mode === 'retrieve'
          && set.datasetlifecycle && this.retrievable.indexOf(set.datasetlifecycle.archiveStatusMessage) !== -1 && set.size > 0) {
          activeSets.push(set);
        }
      }
      this.dataSource = new MatTableDataSource(activeSets);
    } else {
      this.dataSource = new MatTableDataSource(this.datasets);
    }
  }

  /**
   * Return the classes for the view buttons based on what is selected
   * @param m
   */
  getModeButtonClasses(m) {
    const ret = {};
    ret[m.toLowerCase()] = true;
    if (m.toLowerCase() === this.mode) {
      ret['positive'] = true;
    }
    return ret;
  }

  // NOTE: this does not set the page number for the table, there is a
  // `paginate` method but
  // this takes no arguments and requires changing protected vars
  setCurrentPage(n: number) {
    // this.dsTable.onPageChange({ first: n, rows: this.dsTable.rows });
  }

  archiveClickHandle(event) {
    /*const dialogRef = this.dialog.open(DialogComponent, {
      width: 'auto',
      data: { title: 'Really archive?', question: '' }
    });

    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        //this.archiveOrRetrieve(true);
      }
      // this.onClose.emit(result);
    });*/
  }

  /**
   * Sends retrieve command for selected datasets
   * @param {any} event - click handler (not currently used)
   * @memberof DashboardComponent
   */
  retrieveClickHandle(event) {
    const destPath = '/archive/retrieve';
    /*const dialogRef = this.dialog.open(DialogComponent, {
      width: 'auto',
      data: { title: 'Really retrieve?', question: '', input: 'Destination: ' + destPath }
    });*/
    /*
    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        //this.archiveOrRetrieve(false, destPath);
      }
    });
    */
  }

  /**
   * Handles submission of form and subscription
   * of submitted value
   * @param form
   */
  onDestSubmit(form) {
    // TODO maybe wipe the value when submitted?
    this.dest.next(form.value['dest']);
    this.dest.complete();
    this.dest.unsubscribe();
    this.dest = null;
  }
}
